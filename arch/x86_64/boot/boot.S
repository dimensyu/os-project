# arch/x86_64/boot/boot.S

#define ASM_FILE
#include <multiboot2.h>

.section ".boot.head", "ax" 

.global _start

.extern c_start

.extern __multiboot_load_end
.extern KERNEL_BASE
# defined in build/kernel.lds 

multiboot_header: # see multiboot2 spec
  .long MULTIBOOT2_HEADER_MAGIC                 # magic
  .long MULTIBOOT_ARCHITECTURE_I386             # ISA: MULTIBOOT_ARCHITECTURE_I386
  .long multiboot_header_end - multiboot_header # header length
  .long -(MULTIBOOT2_HEADER_MAGIC + MULTIBOOT_ARCHITECTURE_I386 + \
			  (multiboot_header_end - multiboot_header))
  # header checksum
 
address_tag_start:
  .short MULTIBOOT_HEADER_TAG_ADDRESS
  .short MULTIBOOT_HEADER_TAG_OPTIONAL
  .long address_tag_end - address_tag_start
  .long multiboot_header
  .long multiboot_header
  .long __multiboot_load_end
  .long 0 # no "bss"
address_tag_end:

entry_tag_start:
  .short MULTIBOOT_HEADER_TAG_ENTRY_ADDRESS
  .short MULTIBOOT_HEADER_TAG_OPTIONAL
  .long entry_tag_end - entry_tag_start
  .long _start
  .long 0
entry_tag_end:

#framebuffer_tag_start:
#  .short MULTIBOOT_HEADER_TAG_FRAMEBUFFER
#  .short MULTIBOOT_HEADER_TAG_OPTIONAL
#  .long framebuffer_tag_end - framebuffer_tag_start
#  .long 1024, 768
#  .long 32
#  .long 0
#framebuffer_tag_end:

  .short 0, 0          # end tag
  .long 8
multiboot_header_end:

.code32

.align 64

_start:

	movw %ds, %ax
	movw %ax, %es     # make sure they're the same		

	movl $temp_stack_top, %esp
	
	movl (%ebx), %ecx # ecx: the total size of bootinfo
	shrl $2, %ecx     # ecx /= 4
	movl %ebx, %esi
	movl $0x500, %edi
	rep movsl         # move the bootinfo to a known place

#ifdef DO_ARCH_CHECK
	pushfl
	movl (%esp), %ecx
	xorl $0x200000, (%esp)
	popfl
	pushfl
	popl %edx
	cmpl %ecx, %edx
	je die            # check if support cpuid

	movl $0x80000000, %eax
	cpuid
	cmpl $0x80000004, %eax
	jb die

	movl $0x80000001, %eax
	cpuid             # check if it supports x86_64
	btl $29, %edx
	jnc die
#endif /* DO_ARCH_CHECK */

	jmp c_start

/*
	movl $hex_val_table32 + 9, %esi
	movl $8, %ecx
	movl %ebx, %eax
	movl %ebx, %edx
1:
	shrl $4, %edx
	andl $15, %eax
	cmpl $9, %eax
	ja 2f
	addl $48, %eax
	jmp 3f
2:
	addl $55, %eax
3:
	movb %al, (%esi)
	decl %esi
	movl %edx, %eax
	loop 1b

	decl %esi
	call print

	cli
	hlt
*/

#ifdef DO_ARCH_CHECK
die:
	movl $message, %esi
	movb $0x04, %ah
	call print_with_color
	cli
	hlt
	jmp .

message:
  .asciz "[halt]:Your machine do not support x86_64. Please consider changing your machine."
#endif /* DO_ARCH_CHECK */

/*
#	subroutines
#   @print
#	%esi -- the address of the string
print:
	movb $0x0f, %ah
print_with_color:
	movl print_pos, %edi
1:
	lodsb
	testb %al, %al
	jz 2f
	movw %ax, (%edi)
	addl $2, %edi
	jmp 1b
2:
	movl %edi, print_pos
	ret
*/

#   @clear_4k_page
#   %esi -- the page address(ALIGNED!)
clear_4k_page:
	movl $0x1000, %ecx
	pxor %xmm0, %xmm0
1:
	movntdq %xmm0, (%esi)
	movntdq %xmm0, 16(%esi)
	movntdq %xmm0, 32(%esi)
	movntdq %xmm0, 48(%esi)
	movntdq %xmm0, 64(%esi)
	movntdq %xmm0, 80(%esi)
	movntdq %xmm0, 96(%esi)
	movntdq %xmm0, 112(%esi)
	addl $128, %esi
	subl $128, %ecx
	jnz 1b
	ret

/*
print_pos:
 .long 0xb8000

hex_val_table32:
  .ascii "0x"
  .fill 9, 1, 0
gdt64:
  .quad 0                  # dummy descriptor
  .quad 0x00209a0000000000 # code 64
  .quad 0x0020920000000000 # data 64
*/

.section ".boot.stack", "aw"
  .fill 0x400, 1, 0
temp_stack_top:

